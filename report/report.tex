\documentclass{article}

%Define the listing package
\usepackage{listings} %code highlighter
\usepackage{color} %use color
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
 
%Customize a bit the look
\lstset{ %
backgroundcolor=\color{white}, % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
basicstyle=\footnotesize, % the size of the fonts that are used for the code
breakatwhitespace=false, % sets if automatic breaks should only happen at whitespace
breaklines=true, % sets automatic line breaking
captionpos=b, % sets the caption-position to bottom
commentstyle=\color{mygreen}, % comment style
deletekeywords={...}, % if you want to delete keywords from the given language
escapeinside={\%*}{*)}, % if you want to add LaTeX within your code
extendedchars=true, % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
frame=single, % adds a frame around the code
keepspaces=true, % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
keywordstyle=\color{blue}, % keyword style
% language=Octave, % the language of the code
morekeywords={*,...}, % if you want to add more keywords to the set
numbers=left, % where to put the line-numbers; possible values are (none, left, right)
numbersep=5pt, % how far the line-numbers are from the code
numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
rulecolor=\color{black}, % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
showspaces=false, % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
showstringspaces=false, % underline spaces within strings only
showtabs=false, % show tabs within strings adding particular underscores
stepnumber=1, % the step between two line-numbers. If it's 1, each line will be numbered
stringstyle=\color{mymauve}, % string literal style
tabsize=2, % sets default tabsize to 2 spaces
title=\lstname % show the filename of files included with \lstinputlisting; also try caption instead of title
}
%END of listing package%
 
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}
 
%define Javascript language
\lstdefinelanguage{JavaScript}{
keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
keywordstyle=\color{blue}\bfseries,
ndkeywords={class, export, boolean, throw, implements, import, this},
ndkeywordstyle=\color{darkgray}\bfseries,
identifierstyle=\color{black},
sensitive=false,
comment=[l]{//},
morecomment=[s]{/*}{*/},
commentstyle=\color{purple}\ttfamily,
stringstyle=\color{red}\ttfamily,
morestring=[b]',
morestring=[b]"
}
 
\lstset{
language=JavaScript,
extendedchars=true,
basicstyle=\footnotesize\ttfamily,
showstringspaces=false,
showspaces=false,
numbers=left,
numberstyle=\footnotesize,
numbersep=9pt,
tabsize=2,
breaklines=true,
showtabs=false,
captionpos=b
}

%Package for math fonts
\usepackage{amsfonts}

%To skip a line between paragraphs and avoid indentation
\usepackage{parskip}

%Package to change horizontal margins for a specific part using \begin{adjustwidth}{right change amount}{left change amount}
\usepackage{changepage}

%To set margins
\usepackage{geometry}

%New environement to have first line of an enumerate list bold
\newcommand{\step}[1]{\item{\bfseries #1}}
\newcommand{\explanation}[1]{\par #1}
\newenvironment{steps}
  {\begin{enumerate}}
  {\end{enumerate}}

  %Sans-serif font, see https://tex.stackexchange.com/questions/2095/what-is-the-simplest-way-to-typeset-an-entire-document-in-sans-serif
\renewcommand{\familydefault}{\sfdefault}

\title{Report: possible vulnerabilities in the Curve pools logic}
\author{experience, Killari}

\begin{document}
    \maketitle

    \section{Overview}

    In this document, we describe some vulnerabilities that affect all of the Curve pools contracts and might be exploitable by a profit seeking attacker under some conditions, or lead to user losses. Firstly, we note that the accepted proof of path independence for the Curve invariant provided by Angeris and Chitra \cite{angeris2020} is incorrect, meaning that a user cannot expect to get the exact same amount back from a back and forth trade even in the case of zero trade fees. Secondly, due to the way the Stableswap invariant is calculated, it is possible to change the composition of the pools to precise values found to break the computation. Though we have not yet found a profitable attack yet, an attacker may be able to make use of this vulnerability to effectively steal from the pool. 

    \section{Theory}

    \subsection{Stableswap basics}

    For context, we recall the theory of the Stableswap invariant and the way it is implemented in the Curve contracts. Curve is a what has been referred to as a "constant function market maker", or CFMM for short. As described in the original Stableswap paper \cite{stableswap2019}, Given a pool $\vec{x}$ composed of $n$ tokens with respective balances $x_{i}$, a user requesting to swap some amount $\Delta x_{i}$ of tokens $i$ for tokens $j$ should be given an amount $\Delta x_{j}$ such that the following equality remains true with the updated balances: 

    \begin{equation}
        A n^{n} \sum x_{i}+D=A D n^{n}+\frac{D^{n+1}}{n^{n} \prod x_{i}}
    \end{equation}

    Where $A$ is a fixed parameter called the ``amplification factor''. As we can see, it is implied that this equality was true to begin with. In particular, this means that the equation was set with an appropriate value of $D$. This is because as implied in the Stableswap paper, a $D$ that breaks this equality would not necessarily correspond to a spot price of $1$ when balances are close to each other. In order to achieve this, given an initial portfolio of tokens $\vec{x}$, we solve the equation $f(D) = 0$ where: 

    \begin{equation}
        f(D) = A n^{n} \sum x_{i}+D - A D n^{n} -\frac{D^{n+1}}{n^{n} \prod x_{i}}
    \end{equation}

    where $f$ is obtained from Equation 1. With this equation solved, we get the invariant for the current pool composition. As discussed above, finding the amount to give out given an amount in is also calculated by solving the invariant equation for the unknown quantity to give out. 

    \subsection{Path dependence}

    In their 2020 paper, Angeris and Chitra formalize CFMMs like Uniswap's constant product by introducing a \textit{trade function} $\varphi$. Under their formalism, if $\vec{x}$ is the vector representing the reserves, $\vec{\Delta}$ a vector representing the amounts in and $\vec{\Lambda}$ a vector representing the amounts out, a \textit{trade} is a set $\{\vec{\Delta}, \vec{\Lambda}\}$ such that:

    \begin{equation}
        \varphi(\vec{x}, \vec{\Delta}, \vec{\Lambda}) = \varphi(R, 0,0)
    \end{equation}

    They then proceed to define the Curve trading function as: 

    \begin{equation}
        \varphi(\vec{x}, \vec{\Delta}, \vec{\Lambda})=\alpha \mathbf{1}^{T}(\vec{x}+\gamma \vec{\Delta}-\vec{\Lambda})-\beta \prod_{i=1}^{n}\left(x_{i}+\gamma \Delta_{i}-\Lambda_{i}\right)^{-1}
    \end{equation}

    They later state that this function verifies the sufficient condition for path independence that the set of possible trades can be written as: 

    \begin{equation}
        T(R)=\{(\Delta, \Lambda) \mid \psi(R+\Delta-\Lambda) \geq \psi(R)\}
    \end{equation}

    where $\psi$ is a single non decreasing quasiconcave function. The issue in this reasoning lies in the definition of the Curve trading function. More specifically, the Stableswap invariant does not fall under this formalism, because there are no fixed $\alpha$ and $\beta$ such that one could always write a unique trading function as in Equation 3. Indeed, as discussed in Section 2.1, for each specific amount of tokens in the pool, a different D is calculated to make sure Equation 1 holds. This means that we cannot write the condition in Equation 5 above in that context, as a change of balance changes the value of D, and thus the function $\varphi$. 

    We tested this path dependence by executing a specific sequence of trades on a local Ethereum mainnet fork that leads to the user losing 5\% of the original amount they traded, far more than what they would expect to lose from the fees. We were not able to find a sequence of trades that would let the user effectively steal from the pool, but because of the lack of path independence property, this cannot be excluded unless we prove that any sequence of trades never leads to a higher amount out than the initial amount in.

    Nevertheless, this can be considered a vulnerability in the fundamental design of Curve, as this is not the expected behavior. 

    \subsection{Invalid D computations}
    
    The Curve contract attempts to find an appropriate value of D for a given set of current balances by solving the $f(D) = 0$ equation iteratively using the Newton method. Starting with an initial guess $D_{0}$, the next value of D is computed using the following sequence: 

    \begin{equation}
        D_{n+1} = D_{n} - \frac{f(D_{n})}{f'(D_{n})}
    \end{equation}

    This is done until $\| D_{n+1} - D_{n} \| < \varepsilon$ with some user defined $\varepsilon$ precision. It can be shown that in $\mathbb{R}$ the method either converges to a root of the function, that is, a value of D verifying our equation, or does not converge. The number of steps it takes to converge (if it does) is variable. Below is an example implementation of that algorithm in the Curve contracts from \verb {StableSwapUSDT.vy{ : \vspace{5mm}

    \begin{adjustwidth}{-50pt}{-50pt}
        \begin{lstlisting}[language=Python]
        def get_D(xp: uint256[N_COINS]) -> uint256:
            S: uint256 = 0
            for _x in xp:
                S += _x
            if S == 0:
                return 0
        
            Dprev: uint256 = 0
            D: uint256 = S
            Ann: uint256 = self.A * N_COINS
            for _i in range(255):
                D_P: uint256 = D
                for _x in xp:
                    D_P = D_P * D / (_x * N_COINS + 1)  # +1 is to prevent /0
                Dprev = D
                D = (Ann * S + D_P * N_COINS) * D / ((Ann - 1) * D + (N_COINS + 1) * D_P)
                # Equality with the precision of 1
                if D > Dprev:
                    if D - Dprev <= 1:
                        break
                else:
                    if Dprev - D <= 1:
                        break
            return D
        \end{lstlisting}
    \end{adjustwidth}

    As we can see, the algorithm uses 255 iterations, which normally should be enough to converge to a root of the function. But what if we converge to something other than a root of the function before the end of the loop? In $\mathbb{R}$, as stated before, that is not possible. But we see that this algorithm uses 256 bits unsigned integers and integers division. If we encounter any value $D_{i}$ such that $f(D_{i}) < f'(D_{i})$, the integers division will give 0 for $f(D_{n})/f'(D_{n})$, and we will have $D_{i+1} = D_{i}$, thus meeting the condition to terminate the loop before we arrive at an appropriate value. 

    This opens the door for possible attacks that would consist in finding functions $f$ (i.e. pool balances) that cause this early termination, making it so that \verb {get_D{ returns a value of D such that $f(D) \neq 0$. Though we did not find any attack using this vulnerability specifically, it would be useful to check that the D obtained is correct to prevent any creative exploit that we might not have thought of. 

    \section{Setup of possible attacks or bugs}

    Due to the path dependency explained above, it becomes possible in principle for a particular sequence of trade to net a profit, or a loss higher than the trading fees for a trader. In particular for large trades that change the pool composition such that the new $D$ after the trade significantly differs from the original $D$ (for some meaning of significant to be defined through further exploration), the invariant would not give the same amount out as in. 
    
    We demonstrated this issue in a local fork of the Ethereum mainnet, at block 11853997 in the USDT Curve pool. At that block the pool was composed of $1757662794027293/10^{8}$ CDAI, $3506962588474923/10^{8}$ CUSC and $324570592963/10^{8}$ USDT. By swapping $2776297808957086/10^{8}$ CUSDC to CDAI, and then swapping the exact amount of CDAI given out back to CUSD, we end up with $2624090423136564/10^{8}$ CUSDC, or a loss of 5.48\%. 

    This is a specific proof of concept example, we have not explored all possibilities related to the path dependency in the case of trades. We don't know whether it would be possible for an attacker to construct a particular path of trades netting a profit, but we believe the demonstrated vulnerability already constitutes a deviation from the expected behavior of Curve. 

    A profit might come from combining invalid D computations and a back and forth trade, for example if the attacker trades an amount crafted specifically to trigger an invalid D computation and then trades back the same amount that they got out from the first trade. Alternatively, one could find a small amount of liquidity to add in order to trigger an invalid D calculation, and then perform a back and forth trade. The attacker would have to mine such sequences in a simulator. We briefly explored the parameter space with a Python simulator copying the behavior of the Curve contracts on our local machines, but there is a lot left to explore. 

    \section{Mitigation strategies}

    \subsection{Path dependency}

    If our reasoning regarding path dependency is correct, then it is a fundamental limitation of the Stableswap implementation. However, since we couldn't find any profitable sequence of trades in our initial search, one could suspect that this can only lead to losses, which would preclude this vulnerability from ever becoming an attack vector. In order to be confident that it is the case, one would need to formally analyze the properties of the Stableswap system and prove that the path dependency can only lead to losses. As long as this is not proved, the door is opened to potential profit motivated exploitation of this aspect of the automated market maker. 

    \subsection{Invalid Ds}

    To prevent any potential exploit of the invalid D calculations, an easy fix would be to change the contracts to include a check that \textit{after} a trade or the addition / removal of liquidity, the D obtained indeed verifies Equation 1, and refuse the action if it doesn't. 

    Another potential mitigation strategy related to D would be to check that it moves in the ``expected'' direction after each trade. This is already partly done when adding liquidity (fee calculation is missing an assert), but not for trading or when an user is withdrawing liquidity. One would have to explore what the expected direction is for different types of trades analytically. This might prevent some exploits that we have not found in our initial research.

\bibliographystyle{unsrt}
\bibliography{references}

\end{document}